

按下 Ctrl+A 再按 C 以進入 QEMU 的除錯監控介面（QEMU monitor）。
你可以透過輸入 q 命令離開該介面：

-----------------------------------------------------------------------
qemu安裝在這： /opt/homebrew/bin/qemu-system-riscv32
clang安裝在這：/opt/homebrew/opt/llvm/bin/clang

-----------------------------------------------------------------------

c檔案的不同：

.c --> 實作
.h --> 定義介面

-----------------------------------------------------------------------
void *變數名    →  萬用指標，不能直接操作
-----------------------------------------------------------------------

將機器碼的記憶體位址（address）轉回原始碼中的檔名與行號 ：

llvm-addr2line -e kernel.elf 80200334

-----------------------------------------------------------------------

SBI是什麼：
┌──────────────────────────────────┐
│   應用程式 (App)                  │  ← 使用者層
│   例如：瀏覽器、遊戲               │
└────────────┬─────────────────────┘
             │ 系統呼叫 (syscall)
             ↓
┌──────────────────────────────────┐
│   作業系統核心 (OS Kernel)        │  ← 你的程式在這層
│   例如：Linux, 這個教學 OS         │     (Supervisor Mode)
└────────────┬─────────────────────┘
             │ SBI 呼叫 (ecall)  👈 這裡！
             ↓
┌──────────────────────────────────┐
│   SBI 固件 (SBI Firmware)         │  ← 更底層
│   例如：OpenSBI, RustSBI           │     (Machine Mode)
└────────────┬─────────────────────┘
             │ 直接操作硬體
             ↓
┌──────────────────────────────────┐
│   硬體 (Hardware)                 │  ← 最底層
│   CPU、記憶體、UART、定時器等      │
└──────────────────────────────────┘

-----------------------------------------------------------------------


常用的反組譯命令：
# 查看所有代碼段
llvm-objdump -d kernel.elf

# 查看完整資訊(包含原始碼)
llvm-objdump -d -S kernel.elf

# 查看特定區段
llvm-objdump -d -j .text kernel.elf

# 查看符號表
llvm-objdump -t kernel.elf

# 查看段頭資訊
llvm-objdump -h kernel.elf

-----------------------------------------------------------------------

kernel.id:
0x80200000  ┌─────────────┐
            │ .text       │ ← 程序代碼
            ├─────────────┤
            │ .rodata     │ ← 常數
            ├─────────────┤
            │ .data       │ ← 已初始化變數
            ├─────────────┤
            │ .bss        │ ← 未初始化變數
            ├─────────────┤
            │ stack       │ ← 堆疊空間(128KB)
            │   (128KB)   │
            └─────────────┘ ← __stack_top

-----------------------------------------------------------------------
. = ALIGN(4);        // 對齊,. 可能還是 0x80250000
. += 128 * 1024;     // . 變成 0x80250000 + 128KB = 0x80270000
__stack_top = .;     // 記錄堆疊頂端 = 0x80270000
```

在程序啟動時,會把**堆疊指針(SP)** 設定為 `__stack_top`,然後堆疊就會**往下成長**:
```
__stack_top (0x80270000) ┐  ← SP 從這裡開始
                         │
        ↓ 堆疊往下長 ↓    │ 128KB 空間
                         │
                         ┘
__bss_end (0x80250000)


-----------------------------------------------------------------------
#include <stdarg.h>  // 需要引入這個標頭檔

va_list   // 定義一個變數來存放參數
va_start  // 開始讀取可變參數
va_arg    // 取出下一個參數
va_end    // 結束，清理資源


# c型別 ========================================================================
                          無符號整數 (unsigned)
================================================================================
┌─────────────┬─────────────┬─────────────┬──────────────────────────────┐
│   型別      │   位元數    │    Bytes    │           範圍               │
├─────────────┼─────────────┼─────────────┼──────────────────────────────┤
│  uint8_t    │   8 bits    │   1 byte    │  0 ~ 255                     │
├─────────────┼─────────────┼─────────────┼──────────────────────────────┤
│  uint16_t   │  16 bits    │  2 bytes    │  0 ~ 65,535                  │
├─────────────┼─────────────┼─────────────┼──────────────────────────────┤
│  uint32_t   │  32 bits    │  4 bytes    │  0 ~ 4,294,967,295           │
├─────────────┼─────────────┼─────────────┼──────────────────────────────┤
│  uint64_t   │  64 bits    │  8 bytes    │  0 ~ 18,446,744,073,709,551,│
│             │             │             │  615                         │
└─────────────┴─────────────┴─────────────┴──────────────────────────────┘


================================================================================
                           有符號整數 (signed)
================================================================================
┌─────────────┬─────────────┬─────────────┬──────────────────────────────┐
│   型別      │   位元數    │    Bytes    │           範圍               │
├─────────────┼─────────────┼─────────────┼──────────────────────────────┤
│   int8_t    │   8 bits    │   1 byte    │  -128 ~ 127                  │
├─────────────┼─────────────┼─────────────┼──────────────────────────────┤
│  int16_t    │  16 bits    │  2 bytes    │  -32,768 ~ 32,767            │
├─────────────┼─────────────┼─────────────┼──────────────────────────────┤
│  int32_t    │  32 bits    │  4 bytes    │  -2,147,483,648 ~            │
│             │             │             │   2,147,483,647              │
├─────────────┼─────────────┼─────────────┼──────────────────────────────┤
│  int64_t    │  64 bits    │  8 bytes    │  超大範圍                    │
└─────────────┴─────────────┴─────────────┴──────────────────────────────┘



-----------------------------------------------------------------------

__asm__ __volatile__("ecall"
    ↑      ↑          ↑
    │      │          └─ 組合語言指令
    │      └─ 不要優化
    └─ 這是組合語言

    : "=r"(a0), "=r"(a1)
      ↑    ↑      ↑    ↑
      │    │      │    └─ 輸出到 C 變數 a1
      │    │      └─ 輸出到 C 變數 a0
      │    └─ 從暫存器寫入
      └─ 這是輸出列表

    : "r"(a0), "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5),
      ↑   ↑     ↑   ↑
      │   │     │   └─ C 變數 a1
      │   │     └─ C 變數 a0
      │   └─ 放到暫存器
      └─ 這是輸入列表
      
      "r"(a6), "r"(a7)
      ↑   ↑     ↑   ↑
      │   │     │   └─ C 變數 a7 (擴展 ID)
      │   │     └─ C 變數 a6 (功能 ID)
      │   └─ 放到暫存器
      └─ 輸入列表（續）

    : "memory");
      ↑
      └─ 破壞列表：可能改變記憶體
```

---

## 🎬 執行流程
```
步驟 1：準備輸入
┌─────────────────────────────┐
│ 把 C 變數放到暫存器          │
│ a0 暫存器 ← C 變數 a0 ('A') │
│ a1 暫存器 ← C 變數 a1 (0)   │
│ ...                         │
│ a6 暫存器 ← C 變數 a6 (0)   │
│ a7 暫存器 ← C 變數 a7 (1)   │
└─────────────────────────────┘
            ↓
步驟 2：執行組合語言
┌─────────────────────────────┐
│ ecall                       │
│ - CPU 切換到 Machine Mode   │
│ - SBI 處理請求              │
│ - SBI 修改 a0, a1           │
└─────────────────────────────┘
            ↓
步驟 3：讀取輸出
┌─────────────────────────────┐
│ 把暫存器的值讀回 C 變數      │
│ C 變數 a0 ← a0 暫存器 (0)   │
│ C 變數 a1 ← a1 暫存器 (0)   │
└─────────────────────────────┘

