SATP 暫存器是什麼？
SATP = Supervisor Address Translation and Protection

這是 RISC-V 架構中的一個特殊暫存器 (CSR)
用來控制虛擬記憶體系統


satp 暫存器:
┌───────────────────────  ┐
│ [MODE]  [ASID] [PPN]    │
│ 啟用/模式  ID  頁表開始位址│
└───────────────────────  ┘
```

## SATP 暫存器的結構 (32-bit RISC-V)
```
satp 暫存器 (32 bits):
┌──────┬────────┬──────────────────────┐
│ MODE │  ASID  │         PPN          │
│1 bit │ 9 bits │      22 bits         │
└──────┴────────┴──────────────────────┘
  31     30  22   21                  0

MODE (bit 31):
- 0 = Bare mode (關閉分頁，直接使用物理位址)
- 1 = Sv32 mode (開啟 Sv32 分頁)

ASID (Address Space IDentifier, bit 22-30):
- 位址空間識別碼 (用來區分不同 process)

PPN (Physical Page Number, bit 0-21):
- 第一層頁表的物理頁號


SATP_SV32 的定義
c#define SATP_SV32 (1u << 31)
```

**分解:**
```
1u << 31  表示將 1 左移 31 位

Binary:
1 << 31 = 1000_0000_0000_0000_0000_0000_0000_0000
          ↑
        bit 31 = 1

Hexadecimal:
= 0x8000_0000

意義: 設定 MODE bit 為 1，啟用 Sv32 分頁模式
```

## Sv32 是什麼？

**Sv32** = **Supervisor mode, 32-bit virtual addressing**
```
Sv32 的特點:
- 32-bit 虛擬位址空間 (4GB)
- 32-bit 物理位址空間 (4GB)
- 二層頁表結構
- 4KB 頁面大小
```

### **對比不同模式**
```
Bare Mode (MODE = 0):
虛擬位址 = 物理位址 (不轉換)
┌────────┐
│ 0x1000 │ 虛擬位址
└────────┘
    ↓ 直接使用
┌────────┐
│ 0x1000 │ 物理位址
└────────┘

Sv32 Mode (MODE = 1):
虛擬位址 → (透過頁表轉換) → 物理位址
┌────────┐
│ 0x1000 │ 虛擬位址
└────────┘
    ↓ 查頁表
┌────────┐
│ 0x8000 │ 物理位址
└────────┘


如何使用 SATP 暫存器 :

啟用 Sv32 分頁的完整流程

c// 步驟 1: 建立頁表
uint32_t *page_table = (uint32_t *) alloc_pages(1);  // 例如: 0x8000_0000

// 步驟 2: 設定頁表內容 (映射虛擬位址到物理位址)
map_page(page_table, 0x1000_0000, 0x8200_0000, PAGE_R | PAGE_W | PAGE_U);
map_page(page_table, 0x1000_1000, 0x8201_0000, PAGE_R | PAGE_W | PAGE_U);
// ... 更多映射 ...

// 步驟 3: 計算 satp 的值
uint32_t page_table_ppn = (uint32_t) page_table / PAGE_SIZE;
// 假設 page_table = 0x8000_0000
// page_table_ppn = 0x8000_0000 / 4096 = 0x80000

uint32_t satp_value = SATP_SV32 | page_table_ppn;
// = 0x8000_0000 | 0x80000
// = 0x8008_0000

// 步驟 4: 寫入 satp 暫存器，啟用分頁！
__asm__ __volatile__("csrw satp, %0" : : "r"(satp_value));

// 步驟 5: 刷新 TLB (Translation Lookaside Buffer)
__asm__ __volatile__("sfence.vma");

// 🎉 現在虛擬記憶體系統已啟用！
```

### **satp 暫存器的值**
```
計算 satp 的值:

假設第一層頁表在物理位址 0x8000_0000

1. 計算 PPN:
   PPN = 0x8000_0000 / 4096 = 0x80000

2. 設定 MODE = 1 (Sv32):
   MODE bit = bit 31 = 1

3. 組合 (假設 ASID = 0):
   satp = (MODE << 31) | (ASID << 22) | PPN
        = (1 << 31) | (0 << 22) | 0x80000
        = 0x8000_0000 | 0x0 | 0x80000
        = 0x8008_0000

Binary 表示:
┌──┬─────────┬──────────────────────┐
│1 │000000000│00000010000000000000000│
└──┴─────────┴──────────────────────┘
 ↑      ↑              ↑
MODE   ASID           PPN
```

## 硬體如何使用 SATP

### **位址轉換過程**
```
1. CPU 執行指令，需要存取虛擬位址 0x1234_5678

2. MMU (Memory Management Unit) 讀取 satp 暫存器:
   satp = 0x8008_0000
   
3. 檢查 MODE bit (bit 31):
   MODE = 1 → Sv32 模式啟用 ✅
   
4. 取出 PPN (bit 0-21):
   PPN = 0x80000
   第一層頁表基址 = 0x80000 × 4096 = 0x8000_0000

5. 使用這個頁表進行位址轉換:
   虛擬位址 0x1234_5678
   ↓ (透過頁表查詢)
   物理位址 0x8200_5678
   
6. 從物理位址讀取資料
```

### **視覺化流程**
```
CPU 執行:
lw a0, 0x1234_5678

    ↓
┌─────────────────┐
│  讀取 satp      │
│  satp=0x8008000 │
└─────────────────┘
    ↓
┌─────────────────┐
│  MODE = 1?      │ ← 檢查 bit 31
│  YES → Sv32     │
└─────────────────┘
    ↓
┌─────────────────┐
│  取出 PPN       │
│  PPN = 0x80000  │
└─────────────────┘
    ↓
┌─────────────────┐
│ 頁表基址        │
│ = 0x8000_0000   │
└─────────────────┘
    ↓
┌─────────────────┐
│ 查詢頁表轉換    │
│ 0x1234_5678     │
│   → 0x8200_5678 │
└─────────────────┘
    ↓
┌─────────────────┐
│ 讀取物理記憶體  │
│ 0x8200_5678     │
└─────────────────┘
```

## ASID 的作用

**ASID** = Address Space IDentifier (位址空間識別碼)

### **為什麼需要 ASID？**
```
沒有 ASID 的問題:

Process A 切換到 Process B:
1. 切換頁表 (修改 satp 的 PPN)
2. 必須清空整個 TLB ❌ (很慢！)

有 ASID 的好處:

Process A (ASID=1):
TLB: {虛擬頁 0x100, ASID=1} → 物理頁 0x8000

Process B (ASID=2):
TLB: {虛擬頁 0x100, ASID=2} → 物理頁 0x9000

切換 Process 時:
✅ TLB 不需要清空
✅ 透過 ASID 區分不同 process 的映射
✅ 更快的 context switch


設定 ASID
c// Process A
uint32_t satp_proc_a = SATP_SV32 | (1 << 22) | page_table_ppn_a;
//                                  ↑ ASID = 1

// Process B  
uint32_t satp_proc_b = SATP_SV32 | (2 << 22) | page_table_ppn_b;
//                                  ↑ ASID = 2

// 切換到 Process A
__asm__ __volatile__("csrw satp, %0" : : "r"(satp_proc_a));

// 切換到 Process B
__asm__ __volatile__("csrw satp, %0" : : "r"(satp_proc_b));


實際操作範例
開機流程中的分頁啟用
cvoid kernel_main(void) {
    printf("Kernel started\n");
    
    // 1. 分配第一層頁表
    uint32_t *page_table = (uint32_t *) alloc_pages(1);
    memset(page_table, 0, PAGE_SIZE);  // 清空
    
    // 2. 建立 Kernel 的記憶體映射
    // 將 0x8000_0000 ~ 0x8040_0000 (Kernel Code/Data)
    // 映射到相同的虛擬位址 (Identity Mapping)
    for (paddr_t paddr = 0x8000_0000; paddr < 0x8040_0000; paddr += PAGE_SIZE) {
        map_page(page_table, paddr, paddr, PAGE_R | PAGE_W | PAGE_X);
    }
    
    // 3. 建立 User Process 的記憶體映射
    map_page(page_table, 0x1000_0000, 0x8200_0000, PAGE_R | PAGE_X | PAGE_U);
    map_page(page_table, 0x1000_1000, 0x8201_0000, PAGE_R | PAGE_W | PAGE_U);
    
    // 4. 啟用 Sv32 分頁模式
    uint32_t satp = SATP_SV32 | ((uint32_t) page_table / PAGE_SIZE);
    __asm__ __volatile__(
        "csrw satp, %0\n"    // 寫入 satp
        "sfence.vma\n"        // 刷新 TLB
        : : "r"(satp)
    );
    
    printf("Paging enabled! satp = 0x%x\n", satp);
    
    // 🎉 現在所有記憶體存取都會透過虛擬位址！
}


讀取和修改 satp


c// 讀取當前的 satp 值
uint32_t read_satp(void) {
    uint32_t satp;
    __asm__ __volatile__("csrr %0, satp" : "=r"(satp));
    return satp;
}

// 寫入新的 satp 值
void write_satp(uint32_t satp) {
    __asm__ __volatile__(
        "csrw satp, %0\n"
        "sfence.vma\n"  // 必須刷新 TLB！
        : : "r"(satp)
    );
}

// 解析 satp
void parse_satp(uint32_t satp) {
    uint32_t mode = (satp >> 31) & 0x1;
    uint32_t asid = (satp >> 22) & 0x1FF;
    uint32_t ppn = satp & 0x3FFFFF;
    
    printf("SATP Analysis:\n");
    printf("  MODE: %s\n", mode ? "Sv32" : "Bare");
    printf("  ASID: %d\n", asid);
    printf("  PPN:  0x%x\n", ppn);
    printf("  Page Table Base: 0x%x\n", ppn * PAGE_SIZE);
}
```

## 為什麼需要 sfence.vma？

**sfence.vma** = Supervisor Fence for Virtual Memory Addressing
```
問題: TLB 快取了舊的位址轉換結果

Before:
satp 指向頁表 A
TLB 快取:
  {虛擬頁 0x100 → 物理頁 0x8000}

修改 satp:
satp 現在指向頁表 B

但 TLB 還是舊的快取! ❌
  {虛擬頁 0x100 → 物理頁 0x8000}  (錯誤!)

解決: 執行 sfence.vma
清空 TLB 快取 ✅

After:
TLB 被清空，下次存取會重新查詢頁表
```

## 不同架構的對比
```
RISC-V (32-bit):
┌──────┬────────┬──────────────────────┐
│ MODE │  ASID  │         PPN          │
│1 bit │ 9 bits │      22 bits         │
└──────┴────────┴──────────────────────┘

RISC-V (64-bit Sv39):
┌──────┬────────┬─────────────────────────────┐
│ MODE │  ASID  │           PPN               │
│4 bits│16 bits │        44 bits              │
└──────┴────────┴─────────────────────────────┘

x86-64 (CR3 暫存器):
沒有 MODE bit，分頁永遠啟用
只有頁表基址
```

## 總結

**SATP_SV32 和 satp 暫存器:**

1. ✅ **satp** = 虛擬記憶體系統的控制暫存器
2. ✅ **SATP_SV32** = `0x8000_0000`，代表啟用 Sv32 分頁模式
3. ✅ **MODE bit (bit 31)**: 控制是否啟用分頁
   - 0 = Bare mode (關閉)
   - 1 = Sv32 mode (開啟)
4. ✅ **PPN (bit 0-21)**: 第一層頁表的物理頁號
5. ✅ **ASID (bit 22-30)**: 區分不同 process，加速 context switch

**使用流程:**
```
1. 建立頁表 → 2. 計算 PPN → 3. 組合 satp 值 → 4. 寫入 satp → 5. 刷新 TLB
關鍵指令:
ccsrw satp, value   // 寫入 satp，啟用分頁
sfence.vma         // 刷新 TLB
這就是 SATP_SV32 的完整解說！它是啟動虛擬記憶體的關鍵開關 🎯




-----------------------------------------------------------------------------------

Q: 如何從虛擬位址 0x1234_5678 轉換成物理位址 0x8200_5678?

前提假設
satp 暫存器 = 0x8008_0000
→ MODE = 1 (Sv32 啟用)
→ PPN = 0x80000
→ 第一層頁表基址 = 0x80000 × 4096 = 0x8000_0000

虛擬位址 = 0x1234_5678
```

## 步驟 1: 分解虛擬位址
```
虛擬位址: 0x1234_5678 (32 bits)

Binary:
0001_0010_0011_0100_0101_0110_0111_1000

分解成三部分:
┌────────────┬────────────┬──────────────┐
│  VPN[1]    │  VPN[0]    │   Offset     │
│  10 bits   │  10 bits   │   12 bits    │
└────────────┴────────────┴──────────────┘
  31      22   21      12   11         0

計算各部分的值:

VPN[1] = bits 31-22 = 0001001000 (binary)
       = (0x1234_5678 >> 22) & 0x3FF
       = 0x48

VPN[0] = bits 21-12 = 1101000101 (binary)
       = (0x1234_5678 >> 12) & 0x3FF
       = 0x345

Offset = bits 11-0  = 011001111000 (binary)
       = 0x1234_5678 & 0xFFF
       = 0x678
```

**視覺化:**
```
虛擬位址: 0x1234_5678
┌──────────┬──────────┬─────────┐
│ VPN[1]   │ VPN[0]   │ Offset  │
│  0x48    │  0x345   │  0x678  │
│  (72)    │  (837)   │ (1656)  │
└──────────┴──────────┴─────────┘
```

## 步驟 2: 查第一層頁表
```
第一層頁表基址 = 0x8000_0000 (從 satp 得到)
VPN[1] = 0x48 (十進位: 72)

第一層 PTE 的位址 = 頁表基址 + VPN[1] × 4
                  = 0x8000_0000 + 0x48 × 4
                  = 0x8000_0000 + 0x120
                  = 0x8000_0120

讀取記憶體 0x8000_0120 的內容 (假設):
PTE = 0x20400001
```

**解析第一層 PTE:**
```
PTE = 0x20400001

Binary:
0010_0000_0100_0000_0000_0000_0000_0001
└─────────────┬────────────┘ └───┬───┘
            PPN              Flags

PPN = bits 31-10 = 0x81000
V   = bit 0      = 1 (有效)

意義: 這個 PTE 指向「第二層頁表」
第二層頁表基址 = 0x81000 × 4096
              = 0x8100_0000
```

**視覺化:**
```
記憶體:
0x8000_0000: ┌──────────────────┐
             │ table1[0] = ...  │
             │ table1[1] = ...  │
             │ ...              │
0x8000_0120: │ table1[72] =     │ ← VPN[1]=0x48 (索引 72)
             │   0x20400001     │ ← 讀到這個值
             │ ...              │
             └──────────────────┘
                     ↓
              解析 PTE
                     ↓
             PPN = 0x81000
                     ↓
             × 4096 (PAGE_SIZE)
                     ↓
         第二層頁表在 0x8100_0000
```

## 步驟 3: 查第二層頁表
```
第二層頁表基址 = 0x8100_0000 (從第一層 PTE 得到)
VPN[0] = 0x345 (十進位: 837)

第二層 PTE 的位址 = 第二層頁表基址 + VPN[0] × 4
                  = 0x8100_0000 + 0x345 × 4
                  = 0x8100_0000 + 0xD14
                  = 0x8100_0D14

讀取記憶體 0x8100_0D14 的內容 (假設):
PTE = 0x20800017
```

**解析第二層 PTE:**
```
PTE = 0x20800017

Binary:
0010_0000_1000_0000_0000_0000_0001_0111
└─────────────┬────────────┘ └───┬───┘
            PPN              Flags

PPN = bits 31-10 = 0x82000
V   = bit 0      = 1 (有效)
R   = bit 1      = 1 (可讀)
W   = bit 2      = 1 (可寫)
X   = bit 3      = 0 (不可執行)
U   = bit 4      = 1 (使用者可存取)

意義: 這個 PTE 指向「實際的物理頁面」
物理頁面基址 = 0x82000 × 4096
            = 0x8200_0000
```

**視覺化:**
```
記憶體:
0x8100_0000: ┌──────────────────┐
             │ table0[0] = ...  │
             │ table0[1] = ...  │
             │ ...              │
0x8100_0D14: │ table0[837] =    │ ← VPN[0]=0x345 (索引 837)
             │   0x20800017     │ ← 讀到這個值
             │ ...              │
             └──────────────────┘
                     ↓
              解析 PTE
                     ↓
             PPN = 0x82000
                     ↓
             × 4096 (PAGE_SIZE)
                     ↓
         實際物理頁面在 0x8200_0000
```

## 步驟 4: 計算最終物理位址
```
物理頁面基址 = 0x8200_0000 (從第二層 PTE 得到)
Offset       = 0x678 (從虛擬位址得到)

物理位址 = 物理頁面基址 + Offset
        = 0x8200_0000 + 0x678
        = 0x8200_0678

完成！
虛擬位址 0x1234_5678 → 物理位址 0x8200_0678
```

## 完整流程圖解
```
虛擬位址: 0x1234_5678
         ↓ 分解
┌────────┬────────┬────────┐
│VPN[1]  │VPN[0]  │Offset  │
│ 0x48   │ 0x345  │ 0x678  │
└───┬────┴───┬────┴───┬────┘
    ↓        │        │
   查第一層    │        │
    ↓        │        │
0x8000_0000  │        │ ← satp 提供的頁表基址
+ 0x48 × 4   │        │
= 0x8000_0120│        │
    ↓        │        │
讀取 PTE     │        │
0x20400001   │        │
    ↓        │        │
取出 PPN     │        │
0x81000      │        │
    ↓        │        │
× 4096       │        │
= 0x8100_0000│        │
    │        ↓        │
    │      查第二層    │
    │        ↓        │
    │   0x8100_0000   │
    │   + 0x345 × 4   │
    │   = 0x8100_0D14 │
    │        ↓        │
    │    讀取 PTE     │
    │    0x20800017   │
    │        ↓        │
    │    取出 PPN     │
    │    0x82000      │
    │        ↓        │
    │    × 4096       │
    │    = 0x8200_0000│
    │        │        ↓
    └────────┴────→ 加上 Offset
                    ↓
            0x8200_0000 + 0x678
                    ↓
            = 0x8200_0678 ✅

最終物理位址: 0x8200_0678
```

## 記憶體內容視覺化
```
實際記憶體佈局:

物理位址 0x8000_0000:
┌─────────────────────────────┐
│ 第一層頁表                    │
│ ┌─────────────────────────┐ │
│ │ [0x000]: 0x00000000     │ │ 無效
│ │ [0x001]: 0x00000000     │ │ 無效
│ │ ...                     │ │
│ │ [0x048]: 0x20400001 ←───┼─┼─ VPN[1] 查這裡
│ │ ...                     │ │   ↓
│ └─────────────────────────┘ │   指向 0x8100_0000
└─────────────────────────────┘

物理位址 0x8100_0000:
┌─────────────────────────────┐
│ 第二層頁表                    │
│ ┌─────────────────────────┐ │
│ │ [0x000]: 0x00000000     │ │ 無效
│ │ [0x001]: 0x00000000     │ │ 無效
│ │ ...                     │ │
│ │ [0x345]: 0x20800017 ←───┼─┼─ VPN[0] 查這裡
│ │ ...                     │ │   ↓
│ └─────────────────────────┘ │   指向 0x8200_0000
└─────────────────────────────┘

物理位址 0x8200_0000:
┌─────────────────────────────┐
│ 實際資料頁面                  │
│ ┌─────────────────────────┐ │
│ │ [0x000]: 0xXXXXXXXX     │ │
│ │ [0x004]: 0xXXXXXXXX     │ │
│ │ ...                     │ │
│ │ [0x678]: 0x12345678 ←───┼─┼─ Offset 定位到這裡
│ │ ...                     │ │   ← 這就是我們要存取的資料！
│ └─────────────────────────┘ │
└─────────────────────────────┘
```

## 用表格整理

| 步驟 | 動作 | 輸入 | 計算 | 輸出 |
|------|------|------|------|------|
| 1 | 分解虛擬位址 | 0x1234_5678 | 位元運算 | VPN[1]=0x48, VPN[0]=0x345, Offset=0x678 |
| 2 | 查第一層頁表 | VPN[1]=0x48 | 0x8000_0000 + 0x48×4 | PTE=0x20400001 |
| 3 | 解析第一層PTE | 0x20400001 | PPN = 0x81000 | 第二層頁表在 0x8100_0000 |
| 4 | 查第二層頁表 | VPN[0]=0x345 | 0x8100_0000 + 0x345×4 | PTE=0x20800017 |
| 5 | 解析第二層PTE | 0x20800017 | PPN = 0x82000 | 物理頁面在 0x8200_0000 |
| 6 | 加上 Offset | Offset=0x678 | 0x8200_0000 + 0x678 | 物理位址 0x8200_0678 ✅ |

## 關鍵點總結

**為什麼是 0x8200_5678？（你的原例子）**

如果虛擬位址是 `0x1234_5678`，最終物理位址的 Offset 部分（最後 12 bits）**一定保持不變**：
```
虛擬位址: 0x1234_5678
                 └──┘ 最後 3 位 (12 bits) = 0x678

物理位址: 0x8200_0678
                 └──┘ 最後 3 位 (12 bits) = 0x678 (相同！)
所以如果你看到結果是 0x8200_5678，那虛擬位址的 Offset 應該是 0x678，但你寫的例子可能是為了說明概念，實際數字可能不同。
核心概念:

✅ VPN[1] 找第一層頁表的項目 → 得到第二層頁表位址
✅ VPN[0] 找第二層頁表的項目 → 得到物理頁面位址
✅ Offset 在物理頁面內的偏移 → 得到最終物理位址
✅ Offset 永遠不變 (虛擬和物理的最後 12 bits 相同)

這就是完整的位址轉換過程！🎯