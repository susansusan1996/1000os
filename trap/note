csrr __tmp, scause   # 讀取 scause CSR
```

---
## stvec
stvec = Supervisor Trap Vector
        ^^^^^^^^^^  ^^^^  ^^^^^^
        │           │     │
        │           │     └─ 向量（位址）
        │           └─ 陷阱/中斷
        └─ Supervisor 模式
```

**全名：** Supervisor Trap Vector（監督者陷阱向量）

---

## 📝 核心功能

**stvec 儲存「中斷處理程式的位址」**
```
當發生中斷/例外時：
1. CPU 自動跳轉到 stvec 指定的位址
2. 開始執行中斷處理程式
```

---

## 🔍 stvec 的內容

### **格式（32 位元）**
```
stvec 暫存器（32 bits）：

┌─────────────────────────────────┬───┐
│       BASE (30 bits)            │MODE│
│       位址的高 30 位元            │(2) │
└─────────────────────────────────┴───┘
 31                              2 1  0
```

---

### **MODE 欄位（最低 2 位元）**

| MODE 值 | 意思 | 說明 |
|---------|------|------|
| **0** | **Direct（直接模式）** | 所有中斷都跳到同一個位址 |
| **1** | **Vectored（向量模式）** | 不同中斷跳到不同位址 |
| 2-3 | 保留 | 未使用 |

---

### **BASE 欄位（高 30 位元）**

**儲存中斷處理程式的位址（必須 4-byte 對齊）**
```
BASE = 位址 >> 2

例如：
  位址 = 0x80200000
  BASE = 0x80200000 >> 2 = 0x20080000
  
stvec = (BASE << 2) | MODE
      = 0x80200000 | 0
      = 0x80200000




---

### **三個 CSR 的意義**

| CSR        | 全名                     | 內容                |
|------------|-------------------------|---------------------|
| **scause** | Supervisor Cause        | 中斷/例外的原因碼      |
| **stval**  | Supervisor Trap Value   | 相關的值（例如錯誤位址）|
| **sepc**   | Supervisor Exception PC | 中斷發生時的 PC       |

---

#### **scause 的值**
```
scause 最高位元：
  0 = 例外（Exception）
  1 = 中斷（Interrupt）

其餘位元 = 原因碼：
  0  = Instruction address misaligned
  1  = Instruction access fault
  2  = Illegal instruction
  8  = Environment call from U-mode (系統呼叫)
  12 = Instruction page fault
  13 = Load page fault
  15 = Store page fault
  
中斷的值：
  0x80000001 = Supervisor software interrupt
  0x80000005 = Supervisor timer interrupt
  0x80000009 = Supervisor external interrupt
```

---

#### **stval 的值**

根據 scause 的不同，stval 有不同意義：
```
如果是頁面錯誤：
  stval = 造成錯誤的記憶體位址

如果是非法指令：
  stval = 非法指令本身

如果是系統呼叫：
  stval = 0（通常不使用）
```

---

#### **sepc 的值**
```
sepc = 發生中斷/例外時的 PC（程式計數器）

返回時：
  sret 會跳到 sepc 的位址
  
處理系統呼叫時需要修改：
  sepc += 4  // 跳過 ecall 指令（4 bytes）
```

---

## 🎬 完整執行流程
```
═══════════════════════════════════════════════════════════════
時刻 1：中斷發生
═══════════════════════════════════════════════════════════════

硬體自動：
  scause = 8           (系統呼叫)
  sepc = 0x80001234    (ecall 指令的位址)
  stval = 0
  跳轉到 kernel_entry


═══════════════════════════════════════════════════════════════
時刻 2：kernel_entry 保存暫存器
═══════════════════════════════════════════════════════════════

組合語言：
  csrw sscratch, sp
  addi sp, sp, -124
  sw ra, 4*0(sp)
  sw gp, 4*1(sp)
  ...
  sw sp, 4*30(sp)
  
堆疊布局（按照 trap_frame 結構）：
  ┌─────────────┐
  │ ra  = 0x... │ ← sp = 0x800FFF84
  ├─────────────┤
  │ gp  = 0x... │
  ├─────────────┤
  │ ...         │
  └─────────────┘


═══════════════════════════════════════════════════════════════
時刻 3：呼叫 handle_trap
═══════════════════════════════════════════════════════════════

組合語言：
  mv a0, sp              # a0 = 0x800FFF84
  call handle_trap       # 呼叫 C 函數


═══════════════════════════════════════════════════════════════
時刻 4：handle_trap 讀取資訊
═══════════════════════════════════════════════════════════════

C 語言：
  void handle_trap(struct trap_frame *f) {
      // f = 0x800FFF84
      
      // 讀取 CSR
      uint32_t scause = READ_CSR(scause);   // 8
      uint32_t stval = READ_CSR(stval);     // 0
      uint32_t user_pc = READ_CSR(sepc);    // 0x80001234
      
      // 可以讀取暫存器（如果需要）
      // uint32_t a7 = f->a7;  // 系統呼叫號碼
      // uint32_t a0 = f->a0;  // 第一個參數
      
      // 顯示錯誤並停止
      PANIC("unexpected trap scause=%x, stval=%x, sepc=%x\n", 
            scause, stval, user_pc);
  }


═══════════════════════════════════════════════════════════════
時刻 5：PANIC 顯示錯誤
═══════════════════════════════════════════════════════════════

輸出：
  PANIC: kernel.c:42: unexpected trap scause=8, stval=0, sepc=80001234
  
然後：
  while (1) {}  // 無窮迴圈，系統停止